//**** DB CONFIG ****//
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl", "darwin", "windows"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_OS_URL")
}

//****  DB CONFIG END  ****//

//****** User Schema  *****//
enum Theme {
  light
  dark
  system
}

enum Role {
  STUDENT
  AUTHOR
  CUSTOMER
  MEMBER
  ADMIN
  MENTOR
  NOT_ENROLLED
  NA
}

// Add after Theme enum and before Role enum
enum TenantRole {
  OWNER
  ADMIN
  MEMBER
  STAFF
}

// Add new enum for auth providers
enum AuthProvider {
  GOOGLE
  GITHUB
  CREDENTIALS
  EMAIL
}

// Add new model for tenant auth config
model TenantAuthConfig {
  id           String       @id @default(cuid())
  tenantId     String
  provider     AuthProvider
  clientId     String?      @db.Text
  clientSecret String?      @db.Text
  isEnabled    Boolean      @default(false)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, provider])
  @@index([tenantId])
}

enum SupportStatus {
  PENDING
  OPEN
  REOPEN
  RESOLVED
  CLOSED
}

// Modify Tenant model to add auth config relation
model Tenant {
  id                   String       @id @default(cuid())
  name                 String
  domain               String       @unique
  customDomain         String?
  certificateGenerated Boolean      @default(false)
  logo                 String?
  siteConfig           String       @db.Text()
  description          String?      @db.Text()
  isActive             Boolean      @default(true)
  onBoarding           Boolean      @default(false)
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  users                UserTenant[]

  authConfigs            TenantAuthConfig[]
  services               ServiceProvider[]
  secrets                SecretStore[]
  Account                Account[]
  activities             Activities[]
  knowledgeSources       KnowledgeSource[]
  assistantConversations AssistantConversation[]
  sessions               Session[]
  aiAgents               aiAgent[]

  @@index([customDomain])
}

model UserTenant {
  id        String     @id @default(cuid())
  userId    String
  tenantId  String
  role      TenantRole @default(STAFF)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant    Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
}

// Modify User model to add tenant relation
model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  phone         String?
  image         String?
  emailVerified DateTime?
  isActive      Boolean   @default(true)
  role          Role      @default(STUDENT)

  dateJoined DateTime  @default(now())
  createdAt  DateTime  @default(now())
  account    Account[]
  sessions   Session[]

  tenants UserTenant[]
}

//****** User Schema End ******//

//****** Account Schema ******//
model Account {
  id                 String   @id @default(cuid())
  userId             String
  password           String?  @db.Text()
  type               String
  provider           String
  providerAccountId  String   @map("provider_account_id")
  refresh_token      String?  @db.Text()
  access_token       String?  @db.Text()
  expires_at         Int?
  token_type         String?  @db.Text()
  scope              String?  @db.Text()
  createdAt          DateTime @default(now())
  id_token           String?  @db.Text()
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?  @db.Text()
  tenantId           String
  lastActivity       DateTime @default(now())
  tenant             Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId, tenantId])
  @@index([userId])
}

//****** Account Schema End ******//

//****** Session Schema  ******//
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @map("session_token")
  userId       String
  expires      DateTime
  tenantId     String
  accessToken  String?  @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([sessionToken, tenantId])
  @@index([userId])
}

//****** Session Schema End ******//

//****** VerificationToken Schema  ******//
model VerificationToken {
  id         Int      @id @default(autoincrement())
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

//****** VerificationToken Schema End ******//

//****** Course Schema  ******//

//****** Discussion Schema End******//

//****   conversation table ****//
enum MessageUserType {
  USER
  SYSTEM
  VISITOR
}

//****** UserJoinWaiting Schema ******//
model UserJoinWaiting {
  id         Int      @default(autoincrement()) @db.Int()
  email      String
  ip         String?
  sequenceId Int?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now())

  @@unique([id, email])
}

//****** UserJoinWaiting Schema End******//

enum ConfigurationState {
  INITIATED
  AUTHENTICATED
  VOD_CONFIGURED
  CDN_CONFIGURED
  STORAGE_CONFIGURED
  CMS_CONFIGURED
  PAYMENT_CONFIGURED
  EMAIL_CONFIGURED
}

enum ServiceType {
  CMS
  PAYMENTS
  EMAIL
}

model ServiceProvider {
  id             Int                @default(autoincrement()) @db.Int()
  service_type   ServiceType
  provider_name  String             @db.Text()
  tenantId       String
  providerDetail Json?
  state          ConfigurationState @default(INITIATED)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([id])
  @@unique([service_type, tenantId])
  @@index([tenantId])
}

model SecretStore {
  name     String
  secret   String @db.Text
  nonce    String
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([name, tenantId])
  @@index([tenantId])
}

model aiAgent {
  id            String                  @id @default(cuid())
  name          String
  model         String
  temperature   Float
  agentPrompt   String                  @db.Text()
  tenantId      String
  tenant        Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt     DateTime                @default(now())
  updatedAt     DateTime                @updatedAt
  conversations AssistantConversation[]

  @@unique([id, tenantId])
  @@map("ai_agents")
}

enum ActivityType {
  VISIT_PAGE
  WATCH_VIDEO
}

model Activities {
  id         BigInt       @id @default(autoincrement())
  type       ActivityType
  dtOccurred DateTime     @db.Date
  clientIP   String
  userAgent  String
  country    String?
  path       String?
  currency   String?
  timeZone   String?
  city       String?
  domain     String
  tenant     Tenant       @relation(fields: [domain], references: [domain], onDelete: Cascade)

  @@unique([clientIP, dtOccurred, domain, path])
}

enum SourceStatus {
  NEW
  FETCHED
  PROCESSING
  ADDED
  EMBEDDED
  FAILED
}

enum KnowledgeSourceType {
  TXT
  DOCS_WEB_URL
  MARKETING_WEB_URL
  SITEMAP
  URL
  PDF
  DOCX
  VIDEO
}

model KnowledgeSource {
  id             String              @id @default(uuid())
  title          String
  description    String?             @db.Text
  sourceType     KnowledgeSourceType @default(URL) // URL, PDF, DOCX, TXT
  sourceUrl      String?
  content        String?             @db.MediumText
  config         Json? // {model, temperature, maxTokens, systemPrompt}
  metadata       Json?
  status         SourceStatus        @default(NEW)
  errorMessage   String?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  tenantId       String
  parentSourceId String?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([sourceUrl, tenantId])
  @@index([tenantId, parentSourceId])
}

enum JobStatus {
  CREATED
  EXECUTING
  COMPLETED
  FAILED
}

enum JobType {
  EMBEDDING
  SCRAPING
}

model AssistantConversation {
  id            String             @id @default(uuid())
  tenantId      String
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  summary       String?            @db.Text // Stores the summary of the conversation
  sessionId     String // New field: To track the user session (can be visitor ID or logged-in user ID)
  isUserSession Boolean            @default(false)
  messages      AssistantMessage[] // Relation to individual messages
  agentId       String
  agent         aiAgent            @relation(fields: [agentId], references: [id], onDelete: Cascade)
  tenant        Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("assistant_conversations")
}

// Represents an individual message within a conversation
model AssistantMessage {
  id             String                @id @default(uuid())
  conversationId String
  conversation   AssistantConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  role           MessageUserType // "human" or "ai"
  content        String                @db.Text
  createdAt      DateTime              @default(now())

  @@index([conversationId])
  @@map("assistant_messages")
}
